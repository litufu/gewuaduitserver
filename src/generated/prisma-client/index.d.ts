// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  accountingFirm: (where?: AccountingFirmWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  dataRecord: (where?: DataRecordWhereInput) => Promise<boolean>;
  fSSubject: (where?: FSSubjectWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  holder: (where?: HolderWhereInput) => Promise<boolean>;
  member: (where?: MemberWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  stdSubject: (where?: StdSubjectWhereInput) => Promise<boolean>;
  subjectContrast: (where?: SubjectContrastWhereInput) => Promise<boolean>;
  tbSubject: (where?: TbSubjectWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accountingFirm: (
    where: AccountingFirmWhereUniqueInput
  ) => AccountingFirmNullablePromise;
  accountingFirms: (args?: {
    where?: AccountingFirmWhereInput;
    orderBy?: AccountingFirmOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccountingFirm>;
  accountingFirmsConnection: (args?: {
    where?: AccountingFirmWhereInput;
    orderBy?: AccountingFirmOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountingFirmConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  dataRecord: (where: DataRecordWhereUniqueInput) => DataRecordNullablePromise;
  dataRecords: (args?: {
    where?: DataRecordWhereInput;
    orderBy?: DataRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DataRecord>;
  dataRecordsConnection: (args?: {
    where?: DataRecordWhereInput;
    orderBy?: DataRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DataRecordConnectionPromise;
  fSSubject: (where: FSSubjectWhereUniqueInput) => FSSubjectNullablePromise;
  fSSubjects: (args?: {
    where?: FSSubjectWhereInput;
    orderBy?: FSSubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FSSubject>;
  fSSubjectsConnection: (args?: {
    where?: FSSubjectWhereInput;
    orderBy?: FSSubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FSSubjectConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  holder: (where: HolderWhereUniqueInput) => HolderNullablePromise;
  holders: (args?: {
    where?: HolderWhereInput;
    orderBy?: HolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Holder>;
  holdersConnection: (args?: {
    where?: HolderWhereInput;
    orderBy?: HolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HolderConnectionPromise;
  member: (where: MemberWhereUniqueInput) => MemberNullablePromise;
  members: (args?: {
    where?: MemberWhereInput;
    orderBy?: MemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Member>;
  membersConnection: (args?: {
    where?: MemberWhereInput;
    orderBy?: MemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MemberConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  stdSubject: (where: StdSubjectWhereUniqueInput) => StdSubjectNullablePromise;
  stdSubjects: (args?: {
    where?: StdSubjectWhereInput;
    orderBy?: StdSubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StdSubject>;
  stdSubjectsConnection: (args?: {
    where?: StdSubjectWhereInput;
    orderBy?: StdSubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StdSubjectConnectionPromise;
  subjectContrast: (
    where: SubjectContrastWhereUniqueInput
  ) => SubjectContrastNullablePromise;
  subjectContrasts: (args?: {
    where?: SubjectContrastWhereInput;
    orderBy?: SubjectContrastOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubjectContrast>;
  subjectContrastsConnection: (args?: {
    where?: SubjectContrastWhereInput;
    orderBy?: SubjectContrastOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectContrastConnectionPromise;
  tbSubject: (where: TbSubjectWhereUniqueInput) => TbSubjectNullablePromise;
  tbSubjects: (args?: {
    where?: TbSubjectWhereInput;
    orderBy?: TbSubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TbSubject>;
  tbSubjectsConnection: (args?: {
    where?: TbSubjectWhereInput;
    orderBy?: TbSubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TbSubjectConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccountingFirm: (
    data: AccountingFirmCreateInput
  ) => AccountingFirmPromise;
  updateAccountingFirm: (args: {
    data: AccountingFirmUpdateInput;
    where: AccountingFirmWhereUniqueInput;
  }) => AccountingFirmPromise;
  updateManyAccountingFirms: (args: {
    data: AccountingFirmUpdateManyMutationInput;
    where?: AccountingFirmWhereInput;
  }) => BatchPayloadPromise;
  upsertAccountingFirm: (args: {
    where: AccountingFirmWhereUniqueInput;
    create: AccountingFirmCreateInput;
    update: AccountingFirmUpdateInput;
  }) => AccountingFirmPromise;
  deleteAccountingFirm: (
    where: AccountingFirmWhereUniqueInput
  ) => AccountingFirmPromise;
  deleteManyAccountingFirms: (
    where?: AccountingFirmWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createDataRecord: (data: DataRecordCreateInput) => DataRecordPromise;
  updateDataRecord: (args: {
    data: DataRecordUpdateInput;
    where: DataRecordWhereUniqueInput;
  }) => DataRecordPromise;
  updateManyDataRecords: (args: {
    data: DataRecordUpdateManyMutationInput;
    where?: DataRecordWhereInput;
  }) => BatchPayloadPromise;
  upsertDataRecord: (args: {
    where: DataRecordWhereUniqueInput;
    create: DataRecordCreateInput;
    update: DataRecordUpdateInput;
  }) => DataRecordPromise;
  deleteDataRecord: (where: DataRecordWhereUniqueInput) => DataRecordPromise;
  deleteManyDataRecords: (where?: DataRecordWhereInput) => BatchPayloadPromise;
  createFSSubject: (data: FSSubjectCreateInput) => FSSubjectPromise;
  updateFSSubject: (args: {
    data: FSSubjectUpdateInput;
    where: FSSubjectWhereUniqueInput;
  }) => FSSubjectPromise;
  updateManyFSSubjects: (args: {
    data: FSSubjectUpdateManyMutationInput;
    where?: FSSubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertFSSubject: (args: {
    where: FSSubjectWhereUniqueInput;
    create: FSSubjectCreateInput;
    update: FSSubjectUpdateInput;
  }) => FSSubjectPromise;
  deleteFSSubject: (where: FSSubjectWhereUniqueInput) => FSSubjectPromise;
  deleteManyFSSubjects: (where?: FSSubjectWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createHolder: (data: HolderCreateInput) => HolderPromise;
  updateHolder: (args: {
    data: HolderUpdateInput;
    where: HolderWhereUniqueInput;
  }) => HolderPromise;
  updateManyHolders: (args: {
    data: HolderUpdateManyMutationInput;
    where?: HolderWhereInput;
  }) => BatchPayloadPromise;
  upsertHolder: (args: {
    where: HolderWhereUniqueInput;
    create: HolderCreateInput;
    update: HolderUpdateInput;
  }) => HolderPromise;
  deleteHolder: (where: HolderWhereUniqueInput) => HolderPromise;
  deleteManyHolders: (where?: HolderWhereInput) => BatchPayloadPromise;
  createMember: (data: MemberCreateInput) => MemberPromise;
  updateMember: (args: {
    data: MemberUpdateInput;
    where: MemberWhereUniqueInput;
  }) => MemberPromise;
  updateManyMembers: (args: {
    data: MemberUpdateManyMutationInput;
    where?: MemberWhereInput;
  }) => BatchPayloadPromise;
  upsertMember: (args: {
    where: MemberWhereUniqueInput;
    create: MemberCreateInput;
    update: MemberUpdateInput;
  }) => MemberPromise;
  deleteMember: (where: MemberWhereUniqueInput) => MemberPromise;
  deleteManyMembers: (where?: MemberWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createStdSubject: (data: StdSubjectCreateInput) => StdSubjectPromise;
  updateStdSubject: (args: {
    data: StdSubjectUpdateInput;
    where: StdSubjectWhereUniqueInput;
  }) => StdSubjectPromise;
  updateManyStdSubjects: (args: {
    data: StdSubjectUpdateManyMutationInput;
    where?: StdSubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertStdSubject: (args: {
    where: StdSubjectWhereUniqueInput;
    create: StdSubjectCreateInput;
    update: StdSubjectUpdateInput;
  }) => StdSubjectPromise;
  deleteStdSubject: (where: StdSubjectWhereUniqueInput) => StdSubjectPromise;
  deleteManyStdSubjects: (where?: StdSubjectWhereInput) => BatchPayloadPromise;
  createSubjectContrast: (
    data: SubjectContrastCreateInput
  ) => SubjectContrastPromise;
  updateSubjectContrast: (args: {
    data: SubjectContrastUpdateInput;
    where: SubjectContrastWhereUniqueInput;
  }) => SubjectContrastPromise;
  updateManySubjectContrasts: (args: {
    data: SubjectContrastUpdateManyMutationInput;
    where?: SubjectContrastWhereInput;
  }) => BatchPayloadPromise;
  upsertSubjectContrast: (args: {
    where: SubjectContrastWhereUniqueInput;
    create: SubjectContrastCreateInput;
    update: SubjectContrastUpdateInput;
  }) => SubjectContrastPromise;
  deleteSubjectContrast: (
    where: SubjectContrastWhereUniqueInput
  ) => SubjectContrastPromise;
  deleteManySubjectContrasts: (
    where?: SubjectContrastWhereInput
  ) => BatchPayloadPromise;
  createTbSubject: (data: TbSubjectCreateInput) => TbSubjectPromise;
  updateTbSubject: (args: {
    data: TbSubjectUpdateInput;
    where: TbSubjectWhereUniqueInput;
  }) => TbSubjectPromise;
  updateManyTbSubjects: (args: {
    data: TbSubjectUpdateManyMutationInput;
    where?: TbSubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertTbSubject: (args: {
    where: TbSubjectWhereUniqueInput;
    create: TbSubjectCreateInput;
    update: TbSubjectUpdateInput;
  }) => TbSubjectPromise;
  deleteTbSubject: (where: TbSubjectWhereUniqueInput) => TbSubjectPromise;
  deleteManyTbSubjects: (where?: TbSubjectWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accountingFirm: (
    where?: AccountingFirmSubscriptionWhereInput
  ) => AccountingFirmSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  dataRecord: (
    where?: DataRecordSubscriptionWhereInput
  ) => DataRecordSubscriptionPayloadSubscription;
  fSSubject: (
    where?: FSSubjectSubscriptionWhereInput
  ) => FSSubjectSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  holder: (
    where?: HolderSubscriptionWhereInput
  ) => HolderSubscriptionPayloadSubscription;
  member: (
    where?: MemberSubscriptionWhereInput
  ) => MemberSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  stdSubject: (
    where?: StdSubjectSubscriptionWhereInput
  ) => StdSubjectSubscriptionPayloadSubscription;
  subjectContrast: (
    where?: SubjectContrastSubscriptionWhereInput
  ) => SubjectContrastSubscriptionPayloadSubscription;
  tbSubject: (
    where?: TbSubjectSubscriptionWhereInput
  ) => TbSubjectSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DataRecordOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "uploadTime_ASC"
  | "uploadTime_DESC";

export type FileType =
  | "SUBJECTBALANCE"
  | "CHRONOLOGICALACCOUNT"
  | "AUXILIARYACCOUNTING";

export type CompanyType = "DOMESTIC" | "OUTLANDS";

export type TbSubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "show_ASC"
  | "show_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "direction_ASC"
  | "direction_DESC"
  | "order_ASC"
  | "order_DESC";

export type CompanyNature = "STATEOWNED" | "LISTED" | "PLANNEDLISTED" | "OTHER";

export type StdSubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC";

export type MemberOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "role_ASC"
  | "role_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "nature_ASC"
  | "nature_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "address_ASC"
  | "address_DESC"
  | "legalRepresentative_ASC"
  | "legalRepresentative_DESC"
  | "establishDate_ASC"
  | "establishDate_DESC"
  | "registeredCapital_ASC"
  | "registeredCapital_DESC"
  | "paidinCapital_ASC"
  | "paidinCapital_DESC"
  | "businessScope_ASC"
  | "businessScope_DESC";

export type AccountingFirmOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "address_ASC"
  | "address_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "email_ASC"
  | "email_DESC"
  | "contact_ASC"
  | "contact_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "path_ASC"
  | "path_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "type_ASC"
  | "type_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "emailvalidated_ASC"
  | "emailvalidated_DESC"
  | "validateEmailToken_ASC"
  | "validateEmailToken_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetPasswordToken_ASC"
  | "resetPasswordToken_DESC"
  | "resetPasswordExpires_ASC"
  | "resetPasswordExpires_DESC"
  | "name_ASC"
  | "name_DESC"
  | "role_ASC"
  | "role_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC";

export type ProjectRole =
  | "MANAGER"
  | "PARTNER"
  | "ASSISTANT"
  | "QC"
  | "REVIEWPARTNER"
  | "JUDGE"
  | "CPA";

export type HolderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "ratio_ASC"
  | "ratio_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type Role = "ADMIN" | "CUSTOMER";

export type FSSubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "show_ASC"
  | "show_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "direction_ASC"
  | "direction_DESC";

export type SubjectContrastOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "origin_ASC"
  | "origin_DESC"
  | "tb_ASC"
  | "tb_DESC"
  | "fs_ASC"
  | "fs_DESC"
  | "coefficient_ASC"
  | "coefficient_DESC"
  | "direction_ASC"
  | "direction_DESC"
  | "firstClass_ASC"
  | "firstClass_DESC"
  | "secondClass_ASC"
  | "secondClass_DESC";

export interface HolderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ratio?: Maybe<Float>;
  ratio_not?: Maybe<Float>;
  ratio_in?: Maybe<Float[] | Float>;
  ratio_not_in?: Maybe<Float[] | Float>;
  ratio_lt?: Maybe<Float>;
  ratio_lte?: Maybe<Float>;
  ratio_gt?: Maybe<Float>;
  ratio_gte?: Maybe<Float>;
  AND?: Maybe<HolderScalarWhereInput[] | HolderScalarWhereInput>;
  OR?: Maybe<HolderScalarWhereInput[] | HolderScalarWhereInput>;
  NOT?: Maybe<HolderScalarWhereInput[] | HolderScalarWhereInput>;
}

export type AccountingFirmWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  code?: Maybe<String>;
}>;

export interface AccountingFirmUpdateManyWithoutCustomersInput {
  create?: Maybe<
    | AccountingFirmCreateWithoutCustomersInput[]
    | AccountingFirmCreateWithoutCustomersInput
  >;
  delete?: Maybe<
    AccountingFirmWhereUniqueInput[] | AccountingFirmWhereUniqueInput
  >;
  connect?: Maybe<
    AccountingFirmWhereUniqueInput[] | AccountingFirmWhereUniqueInput
  >;
  set?: Maybe<
    AccountingFirmWhereUniqueInput[] | AccountingFirmWhereUniqueInput
  >;
  disconnect?: Maybe<
    AccountingFirmWhereUniqueInput[] | AccountingFirmWhereUniqueInput
  >;
  update?: Maybe<
    | AccountingFirmUpdateWithWhereUniqueWithoutCustomersInput[]
    | AccountingFirmUpdateWithWhereUniqueWithoutCustomersInput
  >;
  upsert?: Maybe<
    | AccountingFirmUpsertWithWhereUniqueWithoutCustomersInput[]
    | AccountingFirmUpsertWithWhereUniqueWithoutCustomersInput
  >;
  deleteMany?: Maybe<
    AccountingFirmScalarWhereInput[] | AccountingFirmScalarWhereInput
  >;
  updateMany?: Maybe<
    | AccountingFirmUpdateManyWithWhereNestedInput[]
    | AccountingFirmUpdateManyWithWhereNestedInput
  >;
}

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  mimetype?: Maybe<String>;
  mimetype_not?: Maybe<String>;
  mimetype_in?: Maybe<String[] | String>;
  mimetype_not_in?: Maybe<String[] | String>;
  mimetype_lt?: Maybe<String>;
  mimetype_lte?: Maybe<String>;
  mimetype_gt?: Maybe<String>;
  mimetype_gte?: Maybe<String>;
  mimetype_contains?: Maybe<String>;
  mimetype_not_contains?: Maybe<String>;
  mimetype_starts_with?: Maybe<String>;
  mimetype_not_starts_with?: Maybe<String>;
  mimetype_ends_with?: Maybe<String>;
  mimetype_not_ends_with?: Maybe<String>;
  type?: Maybe<FileType>;
  type_not?: Maybe<FileType>;
  type_in?: Maybe<FileType[] | FileType>;
  type_not_in?: Maybe<FileType[] | FileType>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface MemberCreateManyWithoutProjectInput {
  create?: Maybe<
    MemberCreateWithoutProjectInput[] | MemberCreateWithoutProjectInput
  >;
  connect?: Maybe<MemberWhereUniqueInput[] | MemberWhereUniqueInput>;
}

export interface CompanyUpdateManyMutationInput {
  type?: Maybe<CompanyType>;
  nature?: Maybe<CompanyNature>;
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
}

export interface MemberCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  role: ProjectRole;
}

export interface AccountingFirmUpdateWithWhereUniqueWithoutCustomersInput {
  where: AccountingFirmWhereUniqueInput;
  data: AccountingFirmUpdateWithoutCustomersDataInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TbSubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TbSubjectWhereInput>;
  AND?: Maybe<
    TbSubjectSubscriptionWhereInput[] | TbSubjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    TbSubjectSubscriptionWhereInput[] | TbSubjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TbSubjectSubscriptionWhereInput[] | TbSubjectSubscriptionWhereInput
  >;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken: String;
  password: String;
  resetPasswordToken: String;
  resetPasswordExpires?: Maybe<Float>;
  name: String;
  role?: Maybe<Role>;
  accountingFirm?: Maybe<AccountingFirmCreateOneWithoutEmployeesInput>;
  projects?: Maybe<ProjectCreateManyInput>;
  dataRecords?: Maybe<DataRecordCreateManyWithoutUsersInput>;
}

export interface SubjectContrastSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubjectContrastWhereInput>;
  AND?: Maybe<
    | SubjectContrastSubscriptionWhereInput[]
    | SubjectContrastSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SubjectContrastSubscriptionWhereInput[]
    | SubjectContrastSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SubjectContrastSubscriptionWhereInput[]
    | SubjectContrastSubscriptionWhereInput
  >;
}

export interface AccountingFirmCreateOneWithoutEmployeesInput {
  create?: Maybe<AccountingFirmCreateWithoutEmployeesInput>;
  connect?: Maybe<AccountingFirmWhereUniqueInput>;
}

export interface HolderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ratio?: Maybe<Float>;
  ratio_not?: Maybe<Float>;
  ratio_in?: Maybe<Float[] | Float>;
  ratio_not_in?: Maybe<Float[] | Float>;
  ratio_lt?: Maybe<Float>;
  ratio_lte?: Maybe<Float>;
  ratio_gt?: Maybe<Float>;
  ratio_gte?: Maybe<Float>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<HolderWhereInput[] | HolderWhereInput>;
  OR?: Maybe<HolderWhereInput[] | HolderWhereInput>;
  NOT?: Maybe<HolderWhereInput[] | HolderWhereInput>;
}

export interface AccountingFirmCreateWithoutEmployeesInput {
  id?: Maybe<ID_Input>;
  name: String;
  code: String;
  address: String;
  phone: String;
  email: String;
  contact: String;
  customers?: Maybe<CompanyCreateManyWithoutAccountingFirmsInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<CompanyType>;
  type_not?: Maybe<CompanyType>;
  type_in?: Maybe<CompanyType[] | CompanyType>;
  type_not_in?: Maybe<CompanyType[] | CompanyType>;
  nature?: Maybe<CompanyNature>;
  nature_not?: Maybe<CompanyNature>;
  nature_in?: Maybe<CompanyNature[] | CompanyNature>;
  nature_not_in?: Maybe<CompanyNature[] | CompanyNature>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  legalRepresentative_not?: Maybe<String>;
  legalRepresentative_in?: Maybe<String[] | String>;
  legalRepresentative_not_in?: Maybe<String[] | String>;
  legalRepresentative_lt?: Maybe<String>;
  legalRepresentative_lte?: Maybe<String>;
  legalRepresentative_gt?: Maybe<String>;
  legalRepresentative_gte?: Maybe<String>;
  legalRepresentative_contains?: Maybe<String>;
  legalRepresentative_not_contains?: Maybe<String>;
  legalRepresentative_starts_with?: Maybe<String>;
  legalRepresentative_not_starts_with?: Maybe<String>;
  legalRepresentative_ends_with?: Maybe<String>;
  legalRepresentative_not_ends_with?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  establishDate_not?: Maybe<DateTimeInput>;
  establishDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  establishDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  establishDate_lt?: Maybe<DateTimeInput>;
  establishDate_lte?: Maybe<DateTimeInput>;
  establishDate_gt?: Maybe<DateTimeInput>;
  establishDate_gte?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  registeredCapital_not?: Maybe<String>;
  registeredCapital_in?: Maybe<String[] | String>;
  registeredCapital_not_in?: Maybe<String[] | String>;
  registeredCapital_lt?: Maybe<String>;
  registeredCapital_lte?: Maybe<String>;
  registeredCapital_gt?: Maybe<String>;
  registeredCapital_gte?: Maybe<String>;
  registeredCapital_contains?: Maybe<String>;
  registeredCapital_not_contains?: Maybe<String>;
  registeredCapital_starts_with?: Maybe<String>;
  registeredCapital_not_starts_with?: Maybe<String>;
  registeredCapital_ends_with?: Maybe<String>;
  registeredCapital_not_ends_with?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  paidinCapital_not?: Maybe<String>;
  paidinCapital_in?: Maybe<String[] | String>;
  paidinCapital_not_in?: Maybe<String[] | String>;
  paidinCapital_lt?: Maybe<String>;
  paidinCapital_lte?: Maybe<String>;
  paidinCapital_gt?: Maybe<String>;
  paidinCapital_gte?: Maybe<String>;
  paidinCapital_contains?: Maybe<String>;
  paidinCapital_not_contains?: Maybe<String>;
  paidinCapital_starts_with?: Maybe<String>;
  paidinCapital_not_starts_with?: Maybe<String>;
  paidinCapital_ends_with?: Maybe<String>;
  paidinCapital_not_ends_with?: Maybe<String>;
  businessScope?: Maybe<String>;
  businessScope_not?: Maybe<String>;
  businessScope_in?: Maybe<String[] | String>;
  businessScope_not_in?: Maybe<String[] | String>;
  businessScope_lt?: Maybe<String>;
  businessScope_lte?: Maybe<String>;
  businessScope_gt?: Maybe<String>;
  businessScope_gte?: Maybe<String>;
  businessScope_contains?: Maybe<String>;
  businessScope_not_contains?: Maybe<String>;
  businessScope_starts_with?: Maybe<String>;
  businessScope_not_starts_with?: Maybe<String>;
  businessScope_ends_with?: Maybe<String>;
  businessScope_not_ends_with?: Maybe<String>;
  holders_every?: Maybe<HolderWhereInput>;
  holders_some?: Maybe<HolderWhereInput>;
  holders_none?: Maybe<HolderWhereInput>;
  accountingFirms_every?: Maybe<AccountingFirmWhereInput>;
  accountingFirms_some?: Maybe<AccountingFirmWhereInput>;
  accountingFirms_none?: Maybe<AccountingFirmWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface CompanyCreateManyWithoutAccountingFirmsInput {
  create?: Maybe<
    | CompanyCreateWithoutAccountingFirmsInput[]
    | CompanyCreateWithoutAccountingFirmsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface AccountingFirmWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  contact?: Maybe<String>;
  contact_not?: Maybe<String>;
  contact_in?: Maybe<String[] | String>;
  contact_not_in?: Maybe<String[] | String>;
  contact_lt?: Maybe<String>;
  contact_lte?: Maybe<String>;
  contact_gt?: Maybe<String>;
  contact_gte?: Maybe<String>;
  contact_contains?: Maybe<String>;
  contact_not_contains?: Maybe<String>;
  contact_starts_with?: Maybe<String>;
  contact_not_starts_with?: Maybe<String>;
  contact_ends_with?: Maybe<String>;
  contact_not_ends_with?: Maybe<String>;
  employees_every?: Maybe<UserWhereInput>;
  employees_some?: Maybe<UserWhereInput>;
  employees_none?: Maybe<UserWhereInput>;
  customers_every?: Maybe<CompanyWhereInput>;
  customers_some?: Maybe<CompanyWhereInput>;
  customers_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<AccountingFirmWhereInput[] | AccountingFirmWhereInput>;
  OR?: Maybe<AccountingFirmWhereInput[] | AccountingFirmWhereInput>;
  NOT?: Maybe<AccountingFirmWhereInput[] | AccountingFirmWhereInput>;
}

export interface CompanyCreateWithoutAccountingFirmsInput {
  id?: Maybe<ID_Input>;
  type: CompanyType;
  nature: CompanyNature;
  name: String;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  holders?: Maybe<HolderCreateManyWithoutCompanyInput>;
}

export interface HolderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HolderWhereInput>;
  AND?: Maybe<HolderSubscriptionWhereInput[] | HolderSubscriptionWhereInput>;
  OR?: Maybe<HolderSubscriptionWhereInput[] | HolderSubscriptionWhereInput>;
  NOT?: Maybe<HolderSubscriptionWhereInput[] | HolderSubscriptionWhereInput>;
}

export interface DataRecordCreateManyWithoutUsersInput {
  create?: Maybe<
    DataRecordCreateWithoutUsersInput[] | DataRecordCreateWithoutUsersInput
  >;
  connect?: Maybe<DataRecordWhereUniqueInput[] | DataRecordWhereUniqueInput>;
}

export interface FSSubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FSSubjectWhereInput>;
  AND?: Maybe<
    FSSubjectSubscriptionWhereInput[] | FSSubjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    FSSubjectSubscriptionWhereInput[] | FSSubjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FSSubjectSubscriptionWhereInput[] | FSSubjectSubscriptionWhereInput
  >;
}

export interface DataRecordCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  accountingFirm: AccountingFirmCreateOneInput;
  company: CompanyCreateOneInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  files?: Maybe<FileCreateManyInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface FileCreateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
}

export interface AccountingFirmSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccountingFirmWhereInput>;
  AND?: Maybe<
    | AccountingFirmSubscriptionWhereInput[]
    | AccountingFirmSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AccountingFirmSubscriptionWhereInput[]
    | AccountingFirmSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AccountingFirmSubscriptionWhereInput[]
    | AccountingFirmSubscriptionWhereInput
  >;
}

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  path: String;
  filename: String;
  mimetype: String;
  type: FileType;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  password?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  name?: Maybe<String>;
  role?: Maybe<Role>;
  accountingFirm?: Maybe<AccountingFirmUpdateOneWithoutEmployeesInput>;
  projects?: Maybe<ProjectUpdateManyInput>;
  dataRecords?: Maybe<DataRecordUpdateManyWithoutUsersInput>;
}

export interface AccountingFirmUpdateInput {
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  contact?: Maybe<String>;
  employees?: Maybe<UserUpdateManyWithoutAccountingFirmInput>;
  customers?: Maybe<CompanyUpdateManyWithoutAccountingFirmsInput>;
}

export interface TbSubjectUpdateManyMutationInput {
  show?: Maybe<String>;
  subject?: Maybe<String>;
  direction?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface UserUpdateManyWithoutAccountingFirmInput {
  create?: Maybe<
    | UserCreateWithoutAccountingFirmInput[]
    | UserCreateWithoutAccountingFirmInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutAccountingFirmInput[]
    | UserUpdateWithWhereUniqueWithoutAccountingFirmInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutAccountingFirmInput[]
    | UserUpsertWithWhereUniqueWithoutAccountingFirmInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface TbSubjectCreateInput {
  id?: Maybe<ID_Input>;
  show: String;
  subject: String;
  direction: String;
  order: Int;
}

export interface UserUpdateWithWhereUniqueWithoutAccountingFirmInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutAccountingFirmDataInput;
}

export interface SubjectContrastUpdateManyMutationInput {
  origin?: Maybe<String>;
  tb?: Maybe<String>;
  fs?: Maybe<String>;
  coefficient?: Maybe<Int>;
  direction?: Maybe<String>;
  firstClass?: Maybe<String>;
  secondClass?: Maybe<String>;
}

export interface UserUpdateWithoutAccountingFirmDataInput {
  email?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  password?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  name?: Maybe<String>;
  role?: Maybe<Role>;
  projects?: Maybe<ProjectUpdateManyInput>;
  dataRecords?: Maybe<DataRecordUpdateManyWithoutUsersInput>;
}

export interface SubjectContrastUpdateInput {
  origin?: Maybe<String>;
  tb?: Maybe<String>;
  fs?: Maybe<String>;
  coefficient?: Maybe<Int>;
  direction?: Maybe<String>;
  firstClass?: Maybe<String>;
  secondClass?: Maybe<String>;
}

export interface ProjectUpdateManyInput {
  create?: Maybe<ProjectCreateInput[] | ProjectCreateInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueNestedInput[]
    | ProjectUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueNestedInput[]
    | ProjectUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface StdSubjectUpdateManyMutationInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
}

export interface ProjectUpdateWithWhereUniqueNestedInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateDataInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectUpdateDataInput {
  accountingFirm?: Maybe<AccountingFirmUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  members?: Maybe<MemberUpdateManyWithoutProjectInput>;
}

export interface ProjectUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
}

export interface AccountingFirmUpdateOneRequiredInput {
  create?: Maybe<AccountingFirmCreateInput>;
  update?: Maybe<AccountingFirmUpdateDataInput>;
  upsert?: Maybe<AccountingFirmUpsertNestedInput>;
  connect?: Maybe<AccountingFirmWhereUniqueInput>;
}

export type HolderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AccountingFirmUpdateDataInput {
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  contact?: Maybe<String>;
  employees?: Maybe<UserUpdateManyWithoutAccountingFirmInput>;
  customers?: Maybe<CompanyUpdateManyWithoutAccountingFirmsInput>;
}

export interface ProjectUpsertWithoutMembersInput {
  update: ProjectUpdateWithoutMembersDataInput;
  create: ProjectCreateWithoutMembersInput;
}

export interface CompanyUpdateManyWithoutAccountingFirmsInput {
  create?: Maybe<
    | CompanyCreateWithoutAccountingFirmsInput[]
    | CompanyCreateWithoutAccountingFirmsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutAccountingFirmsInput[]
    | CompanyUpdateWithWhereUniqueWithoutAccountingFirmsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutAccountingFirmsInput[]
    | CompanyUpsertWithWhereUniqueWithoutAccountingFirmsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export type MemberWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyUpdateWithWhereUniqueWithoutAccountingFirmsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutAccountingFirmsDataInput;
}

export interface MemberUpdateInput {
  project?: Maybe<ProjectUpdateOneRequiredWithoutMembersInput>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  role?: Maybe<ProjectRole>;
}

export interface CompanyUpdateWithoutAccountingFirmsDataInput {
  type?: Maybe<CompanyType>;
  nature?: Maybe<CompanyNature>;
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  holders?: Maybe<HolderUpdateManyWithoutCompanyInput>;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HolderUpdateManyWithoutCompanyInput {
  create?: Maybe<
    HolderCreateWithoutCompanyInput[] | HolderCreateWithoutCompanyInput
  >;
  delete?: Maybe<HolderWhereUniqueInput[] | HolderWhereUniqueInput>;
  connect?: Maybe<HolderWhereUniqueInput[] | HolderWhereUniqueInput>;
  set?: Maybe<HolderWhereUniqueInput[] | HolderWhereUniqueInput>;
  disconnect?: Maybe<HolderWhereUniqueInput[] | HolderWhereUniqueInput>;
  update?: Maybe<
    | HolderUpdateWithWhereUniqueWithoutCompanyInput[]
    | HolderUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | HolderUpsertWithWhereUniqueWithoutCompanyInput[]
    | HolderUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<HolderScalarWhereInput[] | HolderScalarWhereInput>;
  updateMany?: Maybe<
    | HolderUpdateManyWithWhereNestedInput[]
    | HolderUpdateManyWithWhereNestedInput
  >;
}

export interface MemberCreateInput {
  id?: Maybe<ID_Input>;
  project: ProjectCreateOneWithoutMembersInput;
  user: UserCreateOneInput;
  role: ProjectRole;
}

export interface HolderUpdateWithWhereUniqueWithoutCompanyInput {
  where: HolderWhereUniqueInput;
  data: HolderUpdateWithoutCompanyDataInput;
}

export type StdSubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
  name?: Maybe<String>;
}>;

export interface HolderUpdateWithoutCompanyDataInput {
  name?: Maybe<String>;
  ratio?: Maybe<Float>;
}

export interface StdSubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StdSubjectWhereInput[] | StdSubjectWhereInput>;
  OR?: Maybe<StdSubjectWhereInput[] | StdSubjectWhereInput>;
  NOT?: Maybe<StdSubjectWhereInput[] | StdSubjectWhereInput>;
}

export interface HolderUpsertWithWhereUniqueWithoutCompanyInput {
  where: HolderWhereUniqueInput;
  update: HolderUpdateWithoutCompanyDataInput;
  create: HolderCreateWithoutCompanyInput;
}

export interface CompanyUpdateOneRequiredWithoutHoldersInput {
  create?: Maybe<CompanyCreateWithoutHoldersInput>;
  update?: Maybe<CompanyUpdateWithoutHoldersDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutHoldersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface DataRecordUpdateInput {
  accountingFirm?: Maybe<AccountingFirmUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  files?: Maybe<FileUpdateManyInput>;
  users?: Maybe<UserUpdateManyWithoutDataRecordsInput>;
}

export interface CompanyCreateWithoutHoldersInput {
  id?: Maybe<ID_Input>;
  type: CompanyType;
  nature: CompanyNature;
  name: String;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  accountingFirms?: Maybe<AccountingFirmCreateManyWithoutCustomersInput>;
}

export interface HolderUpdateManyWithWhereNestedInput {
  where: HolderScalarWhereInput;
  data: HolderUpdateManyDataInput;
}

export interface CompanyCreateOneWithoutHoldersInput {
  create?: Maybe<CompanyCreateWithoutHoldersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface HolderUpdateManyDataInput {
  name?: Maybe<String>;
  ratio?: Maybe<Float>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  emailvalidated_not?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  validateEmailToken_not?: Maybe<String>;
  validateEmailToken_in?: Maybe<String[] | String>;
  validateEmailToken_not_in?: Maybe<String[] | String>;
  validateEmailToken_lt?: Maybe<String>;
  validateEmailToken_lte?: Maybe<String>;
  validateEmailToken_gt?: Maybe<String>;
  validateEmailToken_gte?: Maybe<String>;
  validateEmailToken_contains?: Maybe<String>;
  validateEmailToken_not_contains?: Maybe<String>;
  validateEmailToken_starts_with?: Maybe<String>;
  validateEmailToken_not_starts_with?: Maybe<String>;
  validateEmailToken_ends_with?: Maybe<String>;
  validateEmailToken_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordToken_not?: Maybe<String>;
  resetPasswordToken_in?: Maybe<String[] | String>;
  resetPasswordToken_not_in?: Maybe<String[] | String>;
  resetPasswordToken_lt?: Maybe<String>;
  resetPasswordToken_lte?: Maybe<String>;
  resetPasswordToken_gt?: Maybe<String>;
  resetPasswordToken_gte?: Maybe<String>;
  resetPasswordToken_contains?: Maybe<String>;
  resetPasswordToken_not_contains?: Maybe<String>;
  resetPasswordToken_starts_with?: Maybe<String>;
  resetPasswordToken_not_starts_with?: Maybe<String>;
  resetPasswordToken_ends_with?: Maybe<String>;
  resetPasswordToken_not_ends_with?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  resetPasswordExpires_not?: Maybe<Float>;
  resetPasswordExpires_in?: Maybe<Float[] | Float>;
  resetPasswordExpires_not_in?: Maybe<Float[] | Float>;
  resetPasswordExpires_lt?: Maybe<Float>;
  resetPasswordExpires_lte?: Maybe<Float>;
  resetPasswordExpires_gt?: Maybe<Float>;
  resetPasswordExpires_gte?: Maybe<Float>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  accountingFirm?: Maybe<AccountingFirmWhereInput>;
  projects_every?: Maybe<ProjectWhereInput>;
  projects_some?: Maybe<ProjectWhereInput>;
  projects_none?: Maybe<ProjectWhereInput>;
  dataRecords_every?: Maybe<DataRecordWhereInput>;
  dataRecords_some?: Maybe<DataRecordWhereInput>;
  dataRecords_none?: Maybe<DataRecordWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutAccountingFirmsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutAccountingFirmsDataInput;
  create: CompanyCreateWithoutAccountingFirmsInput;
}

export interface FileUpdateManyMutationInput {
  path?: Maybe<String>;
  filename?: Maybe<String>;
  mimetype?: Maybe<String>;
  type?: Maybe<FileType>;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<CompanyType>;
  type_not?: Maybe<CompanyType>;
  type_in?: Maybe<CompanyType[] | CompanyType>;
  type_not_in?: Maybe<CompanyType[] | CompanyType>;
  nature?: Maybe<CompanyNature>;
  nature_not?: Maybe<CompanyNature>;
  nature_in?: Maybe<CompanyNature[] | CompanyNature>;
  nature_not_in?: Maybe<CompanyNature[] | CompanyNature>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  legalRepresentative_not?: Maybe<String>;
  legalRepresentative_in?: Maybe<String[] | String>;
  legalRepresentative_not_in?: Maybe<String[] | String>;
  legalRepresentative_lt?: Maybe<String>;
  legalRepresentative_lte?: Maybe<String>;
  legalRepresentative_gt?: Maybe<String>;
  legalRepresentative_gte?: Maybe<String>;
  legalRepresentative_contains?: Maybe<String>;
  legalRepresentative_not_contains?: Maybe<String>;
  legalRepresentative_starts_with?: Maybe<String>;
  legalRepresentative_not_starts_with?: Maybe<String>;
  legalRepresentative_ends_with?: Maybe<String>;
  legalRepresentative_not_ends_with?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  establishDate_not?: Maybe<DateTimeInput>;
  establishDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  establishDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  establishDate_lt?: Maybe<DateTimeInput>;
  establishDate_lte?: Maybe<DateTimeInput>;
  establishDate_gt?: Maybe<DateTimeInput>;
  establishDate_gte?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  registeredCapital_not?: Maybe<String>;
  registeredCapital_in?: Maybe<String[] | String>;
  registeredCapital_not_in?: Maybe<String[] | String>;
  registeredCapital_lt?: Maybe<String>;
  registeredCapital_lte?: Maybe<String>;
  registeredCapital_gt?: Maybe<String>;
  registeredCapital_gte?: Maybe<String>;
  registeredCapital_contains?: Maybe<String>;
  registeredCapital_not_contains?: Maybe<String>;
  registeredCapital_starts_with?: Maybe<String>;
  registeredCapital_not_starts_with?: Maybe<String>;
  registeredCapital_ends_with?: Maybe<String>;
  registeredCapital_not_ends_with?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  paidinCapital_not?: Maybe<String>;
  paidinCapital_in?: Maybe<String[] | String>;
  paidinCapital_not_in?: Maybe<String[] | String>;
  paidinCapital_lt?: Maybe<String>;
  paidinCapital_lte?: Maybe<String>;
  paidinCapital_gt?: Maybe<String>;
  paidinCapital_gte?: Maybe<String>;
  paidinCapital_contains?: Maybe<String>;
  paidinCapital_not_contains?: Maybe<String>;
  paidinCapital_starts_with?: Maybe<String>;
  paidinCapital_not_starts_with?: Maybe<String>;
  paidinCapital_ends_with?: Maybe<String>;
  paidinCapital_not_ends_with?: Maybe<String>;
  businessScope?: Maybe<String>;
  businessScope_not?: Maybe<String>;
  businessScope_in?: Maybe<String[] | String>;
  businessScope_not_in?: Maybe<String[] | String>;
  businessScope_lt?: Maybe<String>;
  businessScope_lte?: Maybe<String>;
  businessScope_gt?: Maybe<String>;
  businessScope_gte?: Maybe<String>;
  businessScope_contains?: Maybe<String>;
  businessScope_not_contains?: Maybe<String>;
  businessScope_starts_with?: Maybe<String>;
  businessScope_not_starts_with?: Maybe<String>;
  businessScope_ends_with?: Maybe<String>;
  businessScope_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export type TbSubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  show?: Maybe<String>;
}>;

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface TbSubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  show?: Maybe<String>;
  show_not?: Maybe<String>;
  show_in?: Maybe<String[] | String>;
  show_not_in?: Maybe<String[] | String>;
  show_lt?: Maybe<String>;
  show_lte?: Maybe<String>;
  show_gt?: Maybe<String>;
  show_gte?: Maybe<String>;
  show_contains?: Maybe<String>;
  show_not_contains?: Maybe<String>;
  show_starts_with?: Maybe<String>;
  show_not_starts_with?: Maybe<String>;
  show_ends_with?: Maybe<String>;
  show_not_ends_with?: Maybe<String>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  direction?: Maybe<String>;
  direction_not?: Maybe<String>;
  direction_in?: Maybe<String[] | String>;
  direction_not_in?: Maybe<String[] | String>;
  direction_lt?: Maybe<String>;
  direction_lte?: Maybe<String>;
  direction_gt?: Maybe<String>;
  direction_gte?: Maybe<String>;
  direction_contains?: Maybe<String>;
  direction_not_contains?: Maybe<String>;
  direction_starts_with?: Maybe<String>;
  direction_not_starts_with?: Maybe<String>;
  direction_ends_with?: Maybe<String>;
  direction_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<TbSubjectWhereInput[] | TbSubjectWhereInput>;
  OR?: Maybe<TbSubjectWhereInput[] | TbSubjectWhereInput>;
  NOT?: Maybe<TbSubjectWhereInput[] | TbSubjectWhereInput>;
}

export interface CompanyUpdateManyDataInput {
  type?: Maybe<CompanyType>;
  nature?: Maybe<CompanyNature>;
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
}

export interface FSSubjectCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  show: String;
  subject: String;
  direction: String;
}

export interface AccountingFirmUpsertNestedInput {
  update: AccountingFirmUpdateDataInput;
  create: AccountingFirmCreateInput;
}

export interface UserUpsertWithWhereUniqueWithoutDataRecordsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutDataRecordsDataInput;
  create: UserCreateWithoutDataRecordsInput;
}

export interface CompanyUpdateOneRequiredInput {
  create?: Maybe<CompanyCreateInput>;
  update?: Maybe<CompanyUpdateDataInput>;
  upsert?: Maybe<CompanyUpsertNestedInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface UserUpdateWithoutDataRecordsDataInput {
  email?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  password?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  name?: Maybe<String>;
  role?: Maybe<Role>;
  accountingFirm?: Maybe<AccountingFirmUpdateOneWithoutEmployeesInput>;
  projects?: Maybe<ProjectUpdateManyInput>;
}

export interface CompanyUpdateDataInput {
  type?: Maybe<CompanyType>;
  nature?: Maybe<CompanyNature>;
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  holders?: Maybe<HolderUpdateManyWithoutCompanyInput>;
  accountingFirms?: Maybe<AccountingFirmUpdateManyWithoutCustomersInput>;
}

export interface UserUpdateManyWithoutDataRecordsInput {
  create?: Maybe<
    UserCreateWithoutDataRecordsInput[] | UserCreateWithoutDataRecordsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutDataRecordsInput[]
    | UserUpdateWithWhereUniqueWithoutDataRecordsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutDataRecordsInput[]
    | UserUpsertWithWhereUniqueWithoutDataRecordsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutDataRecordsInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken: String;
  password: String;
  resetPasswordToken: String;
  resetPasswordExpires?: Maybe<Float>;
  name: String;
  role?: Maybe<Role>;
  accountingFirm?: Maybe<AccountingFirmCreateOneWithoutEmployeesInput>;
  projects?: Maybe<ProjectCreateManyInput>;
}

export interface AccountingFirmCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  code: String;
  address: String;
  phone: String;
  email: String;
  contact: String;
  employees?: Maybe<UserCreateManyWithoutAccountingFirmInput>;
  customers?: Maybe<CompanyCreateManyWithoutAccountingFirmsInput>;
}

export interface DataRecordWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  accountingFirm?: Maybe<AccountingFirmWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  uploadTime?: Maybe<DateTimeInput>;
  uploadTime_not?: Maybe<DateTimeInput>;
  uploadTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  uploadTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  uploadTime_lt?: Maybe<DateTimeInput>;
  uploadTime_lte?: Maybe<DateTimeInput>;
  uploadTime_gt?: Maybe<DateTimeInput>;
  uploadTime_gte?: Maybe<DateTimeInput>;
  files_every?: Maybe<FileWhereInput>;
  files_some?: Maybe<FileWhereInput>;
  files_none?: Maybe<FileWhereInput>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<DataRecordWhereInput[] | DataRecordWhereInput>;
  OR?: Maybe<DataRecordWhereInput[] | DataRecordWhereInput>;
  NOT?: Maybe<DataRecordWhereInput[] | DataRecordWhereInput>;
}

export interface UserCreateWithoutAccountingFirmInput {
  id?: Maybe<ID_Input>;
  email: String;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken: String;
  password: String;
  resetPasswordToken: String;
  resetPasswordExpires?: Maybe<Float>;
  name: String;
  role?: Maybe<Role>;
  projects?: Maybe<ProjectCreateManyInput>;
  dataRecords?: Maybe<DataRecordCreateManyWithoutUsersInput>;
}

export interface AccountingFirmUpdateWithoutCustomersDataInput {
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  contact?: Maybe<String>;
  employees?: Maybe<UserUpdateManyWithoutAccountingFirmInput>;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  accountingFirm: AccountingFirmCreateOneInput;
  company: CompanyCreateOneInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  members?: Maybe<MemberCreateManyWithoutProjectInput>;
}

export interface AccountingFirmUpsertWithWhereUniqueWithoutCustomersInput {
  where: AccountingFirmWhereUniqueInput;
  update: AccountingFirmUpdateWithoutCustomersDataInput;
  create: AccountingFirmCreateWithoutCustomersInput;
}

export interface CompanyCreateOneInput {
  create?: Maybe<CompanyCreateInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface AccountingFirmScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  contact?: Maybe<String>;
  contact_not?: Maybe<String>;
  contact_in?: Maybe<String[] | String>;
  contact_not_in?: Maybe<String[] | String>;
  contact_lt?: Maybe<String>;
  contact_lte?: Maybe<String>;
  contact_gt?: Maybe<String>;
  contact_gte?: Maybe<String>;
  contact_contains?: Maybe<String>;
  contact_not_contains?: Maybe<String>;
  contact_starts_with?: Maybe<String>;
  contact_not_starts_with?: Maybe<String>;
  contact_ends_with?: Maybe<String>;
  contact_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    AccountingFirmScalarWhereInput[] | AccountingFirmScalarWhereInput
  >;
  OR?: Maybe<AccountingFirmScalarWhereInput[] | AccountingFirmScalarWhereInput>;
  NOT?: Maybe<
    AccountingFirmScalarWhereInput[] | AccountingFirmScalarWhereInput
  >;
}

export interface HolderCreateManyWithoutCompanyInput {
  create?: Maybe<
    HolderCreateWithoutCompanyInput[] | HolderCreateWithoutCompanyInput
  >;
  connect?: Maybe<HolderWhereUniqueInput[] | HolderWhereUniqueInput>;
}

export interface AccountingFirmUpdateManyWithWhereNestedInput {
  where: AccountingFirmScalarWhereInput;
  data: AccountingFirmUpdateManyDataInput;
}

export interface AccountingFirmCreateManyWithoutCustomersInput {
  create?: Maybe<
    | AccountingFirmCreateWithoutCustomersInput[]
    | AccountingFirmCreateWithoutCustomersInput
  >;
  connect?: Maybe<
    AccountingFirmWhereUniqueInput[] | AccountingFirmWhereUniqueInput
  >;
}

export interface AccountingFirmUpdateManyDataInput {
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  contact?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  accountingFirm?: Maybe<AccountingFirmWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  members_every?: Maybe<MemberWhereInput>;
  members_some?: Maybe<MemberWhereInput>;
  members_none?: Maybe<MemberWhereInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface MemberUpdateManyWithoutProjectInput {
  create?: Maybe<
    MemberCreateWithoutProjectInput[] | MemberCreateWithoutProjectInput
  >;
  delete?: Maybe<MemberWhereUniqueInput[] | MemberWhereUniqueInput>;
  connect?: Maybe<MemberWhereUniqueInput[] | MemberWhereUniqueInput>;
  set?: Maybe<MemberWhereUniqueInput[] | MemberWhereUniqueInput>;
  disconnect?: Maybe<MemberWhereUniqueInput[] | MemberWhereUniqueInput>;
  update?: Maybe<
    | MemberUpdateWithWhereUniqueWithoutProjectInput[]
    | MemberUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | MemberUpsertWithWhereUniqueWithoutProjectInput[]
    | MemberUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<MemberScalarWhereInput[] | MemberScalarWhereInput>;
  updateMany?: Maybe<
    | MemberUpdateManyWithWhereNestedInput[]
    | MemberUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface MemberUpdateWithWhereUniqueWithoutProjectInput {
  where: MemberWhereUniqueInput;
  data: MemberUpdateWithoutProjectDataInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface MemberUpdateWithoutProjectDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  role?: Maybe<ProjectRole>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type DataRecordWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  password?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  name?: Maybe<String>;
  role?: Maybe<Role>;
  accountingFirm?: Maybe<AccountingFirmUpdateOneWithoutEmployeesInput>;
  projects?: Maybe<ProjectUpdateManyInput>;
  dataRecords?: Maybe<DataRecordUpdateManyWithoutUsersInput>;
}

export type FSSubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AccountingFirmUpdateOneWithoutEmployeesInput {
  create?: Maybe<AccountingFirmCreateWithoutEmployeesInput>;
  update?: Maybe<AccountingFirmUpdateWithoutEmployeesDataInput>;
  upsert?: Maybe<AccountingFirmUpsertWithoutEmployeesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AccountingFirmWhereUniqueInput>;
}

export interface SubjectContrastCreateInput {
  id?: Maybe<ID_Input>;
  origin: String;
  tb: String;
  fs: String;
  coefficient: Int;
  direction: String;
  firstClass: String;
  secondClass: String;
}

export interface AccountingFirmUpdateWithoutEmployeesDataInput {
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  contact?: Maybe<String>;
  customers?: Maybe<CompanyUpdateManyWithoutAccountingFirmsInput>;
}

export interface StdSubjectCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  name: String;
}

export interface AccountingFirmUpsertWithoutEmployeesInput {
  update: AccountingFirmUpdateWithoutEmployeesDataInput;
  create: AccountingFirmCreateWithoutEmployeesInput;
}

export interface MemberUpdateManyMutationInput {
  role?: Maybe<ProjectRole>;
}

export interface DataRecordUpdateManyWithoutUsersInput {
  create?: Maybe<
    DataRecordCreateWithoutUsersInput[] | DataRecordCreateWithoutUsersInput
  >;
  delete?: Maybe<DataRecordWhereUniqueInput[] | DataRecordWhereUniqueInput>;
  connect?: Maybe<DataRecordWhereUniqueInput[] | DataRecordWhereUniqueInput>;
  set?: Maybe<DataRecordWhereUniqueInput[] | DataRecordWhereUniqueInput>;
  disconnect?: Maybe<DataRecordWhereUniqueInput[] | DataRecordWhereUniqueInput>;
  update?: Maybe<
    | DataRecordUpdateWithWhereUniqueWithoutUsersInput[]
    | DataRecordUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | DataRecordUpsertWithWhereUniqueWithoutUsersInput[]
    | DataRecordUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<DataRecordScalarWhereInput[] | DataRecordScalarWhereInput>;
  updateMany?: Maybe<
    | DataRecordUpdateManyWithWhereNestedInput[]
    | DataRecordUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectUpdateOneRequiredWithoutMembersInput {
  create?: Maybe<ProjectCreateWithoutMembersInput>;
  update?: Maybe<ProjectUpdateWithoutMembersDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutMembersInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface DataRecordUpdateWithWhereUniqueWithoutUsersInput {
  where: DataRecordWhereUniqueInput;
  data: DataRecordUpdateWithoutUsersDataInput;
}

export interface ProjectCreateOneWithoutMembersInput {
  create?: Maybe<ProjectCreateWithoutMembersInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface DataRecordUpdateWithoutUsersDataInput {
  accountingFirm?: Maybe<AccountingFirmUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  files?: Maybe<FileUpdateManyInput>;
}

export interface CompanyUpsertWithoutHoldersInput {
  update: CompanyUpdateWithoutHoldersDataInput;
  create: CompanyCreateWithoutHoldersInput;
}

export interface FileUpdateManyInput {
  create?: Maybe<FileCreateInput[] | FileCreateInput>;
  update?: Maybe<
    | FileUpdateWithWhereUniqueNestedInput[]
    | FileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FileUpsertWithWhereUniqueNestedInput[]
    | FileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  connect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  set?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  disconnect?: Maybe<FileWhereUniqueInput[] | FileWhereUniqueInput>;
  deleteMany?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  updateMany?: Maybe<
    FileUpdateManyWithWhereNestedInput[] | FileUpdateManyWithWhereNestedInput
  >;
}

export interface HolderUpdateInput {
  name?: Maybe<String>;
  ratio?: Maybe<Float>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutHoldersInput>;
}

export interface FileUpdateWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  data: FileUpdateDataInput;
}

export interface SubjectContrastWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  origin?: Maybe<String>;
  origin_not?: Maybe<String>;
  origin_in?: Maybe<String[] | String>;
  origin_not_in?: Maybe<String[] | String>;
  origin_lt?: Maybe<String>;
  origin_lte?: Maybe<String>;
  origin_gt?: Maybe<String>;
  origin_gte?: Maybe<String>;
  origin_contains?: Maybe<String>;
  origin_not_contains?: Maybe<String>;
  origin_starts_with?: Maybe<String>;
  origin_not_starts_with?: Maybe<String>;
  origin_ends_with?: Maybe<String>;
  origin_not_ends_with?: Maybe<String>;
  tb?: Maybe<String>;
  tb_not?: Maybe<String>;
  tb_in?: Maybe<String[] | String>;
  tb_not_in?: Maybe<String[] | String>;
  tb_lt?: Maybe<String>;
  tb_lte?: Maybe<String>;
  tb_gt?: Maybe<String>;
  tb_gte?: Maybe<String>;
  tb_contains?: Maybe<String>;
  tb_not_contains?: Maybe<String>;
  tb_starts_with?: Maybe<String>;
  tb_not_starts_with?: Maybe<String>;
  tb_ends_with?: Maybe<String>;
  tb_not_ends_with?: Maybe<String>;
  fs?: Maybe<String>;
  fs_not?: Maybe<String>;
  fs_in?: Maybe<String[] | String>;
  fs_not_in?: Maybe<String[] | String>;
  fs_lt?: Maybe<String>;
  fs_lte?: Maybe<String>;
  fs_gt?: Maybe<String>;
  fs_gte?: Maybe<String>;
  fs_contains?: Maybe<String>;
  fs_not_contains?: Maybe<String>;
  fs_starts_with?: Maybe<String>;
  fs_not_starts_with?: Maybe<String>;
  fs_ends_with?: Maybe<String>;
  fs_not_ends_with?: Maybe<String>;
  coefficient?: Maybe<Int>;
  coefficient_not?: Maybe<Int>;
  coefficient_in?: Maybe<Int[] | Int>;
  coefficient_not_in?: Maybe<Int[] | Int>;
  coefficient_lt?: Maybe<Int>;
  coefficient_lte?: Maybe<Int>;
  coefficient_gt?: Maybe<Int>;
  coefficient_gte?: Maybe<Int>;
  direction?: Maybe<String>;
  direction_not?: Maybe<String>;
  direction_in?: Maybe<String[] | String>;
  direction_not_in?: Maybe<String[] | String>;
  direction_lt?: Maybe<String>;
  direction_lte?: Maybe<String>;
  direction_gt?: Maybe<String>;
  direction_gte?: Maybe<String>;
  direction_contains?: Maybe<String>;
  direction_not_contains?: Maybe<String>;
  direction_starts_with?: Maybe<String>;
  direction_not_starts_with?: Maybe<String>;
  direction_ends_with?: Maybe<String>;
  direction_not_ends_with?: Maybe<String>;
  firstClass?: Maybe<String>;
  firstClass_not?: Maybe<String>;
  firstClass_in?: Maybe<String[] | String>;
  firstClass_not_in?: Maybe<String[] | String>;
  firstClass_lt?: Maybe<String>;
  firstClass_lte?: Maybe<String>;
  firstClass_gt?: Maybe<String>;
  firstClass_gte?: Maybe<String>;
  firstClass_contains?: Maybe<String>;
  firstClass_not_contains?: Maybe<String>;
  firstClass_starts_with?: Maybe<String>;
  firstClass_not_starts_with?: Maybe<String>;
  firstClass_ends_with?: Maybe<String>;
  firstClass_not_ends_with?: Maybe<String>;
  secondClass?: Maybe<String>;
  secondClass_not?: Maybe<String>;
  secondClass_in?: Maybe<String[] | String>;
  secondClass_not_in?: Maybe<String[] | String>;
  secondClass_lt?: Maybe<String>;
  secondClass_lte?: Maybe<String>;
  secondClass_gt?: Maybe<String>;
  secondClass_gte?: Maybe<String>;
  secondClass_contains?: Maybe<String>;
  secondClass_not_contains?: Maybe<String>;
  secondClass_starts_with?: Maybe<String>;
  secondClass_not_starts_with?: Maybe<String>;
  secondClass_ends_with?: Maybe<String>;
  secondClass_not_ends_with?: Maybe<String>;
  AND?: Maybe<SubjectContrastWhereInput[] | SubjectContrastWhereInput>;
  OR?: Maybe<SubjectContrastWhereInput[] | SubjectContrastWhereInput>;
  NOT?: Maybe<SubjectContrastWhereInput[] | SubjectContrastWhereInput>;
}

export interface FileUpdateDataInput {
  path?: Maybe<String>;
  filename?: Maybe<String>;
  mimetype?: Maybe<String>;
  type?: Maybe<FileType>;
}

export interface FileUpdateInput {
  path?: Maybe<String>;
  filename?: Maybe<String>;
  mimetype?: Maybe<String>;
  type?: Maybe<FileType>;
}

export interface FileUpsertWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface FSSubjectUpdateInput {
  name?: Maybe<String>;
  show?: Maybe<String>;
  subject?: Maybe<String>;
  direction?: Maybe<String>;
}

export interface FileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  mimetype?: Maybe<String>;
  mimetype_not?: Maybe<String>;
  mimetype_in?: Maybe<String[] | String>;
  mimetype_not_in?: Maybe<String[] | String>;
  mimetype_lt?: Maybe<String>;
  mimetype_lte?: Maybe<String>;
  mimetype_gt?: Maybe<String>;
  mimetype_gte?: Maybe<String>;
  mimetype_contains?: Maybe<String>;
  mimetype_not_contains?: Maybe<String>;
  mimetype_starts_with?: Maybe<String>;
  mimetype_not_starts_with?: Maybe<String>;
  mimetype_ends_with?: Maybe<String>;
  mimetype_not_ends_with?: Maybe<String>;
  type?: Maybe<FileType>;
  type_not?: Maybe<FileType>;
  type_in?: Maybe<FileType[] | FileType>;
  type_not_in?: Maybe<FileType[] | FileType>;
  AND?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  OR?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
  NOT?: Maybe<FileScalarWhereInput[] | FileScalarWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  validateEmailToken?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
}>;

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface ProjectCreateManyInput {
  create?: Maybe<ProjectCreateInput[] | ProjectCreateInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface FileUpdateManyDataInput {
  path?: Maybe<String>;
  filename?: Maybe<String>;
  mimetype?: Maybe<String>;
  type?: Maybe<FileType>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  type: CompanyType;
  nature: CompanyNature;
  name: String;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  holders?: Maybe<HolderCreateManyWithoutCompanyInput>;
  accountingFirms?: Maybe<AccountingFirmCreateManyWithoutCustomersInput>;
}

export interface DataRecordUpsertWithWhereUniqueWithoutUsersInput {
  where: DataRecordWhereUniqueInput;
  update: DataRecordUpdateWithoutUsersDataInput;
  create: DataRecordCreateWithoutUsersInput;
}

export interface AccountingFirmCreateWithoutCustomersInput {
  id?: Maybe<ID_Input>;
  name: String;
  code: String;
  address: String;
  phone: String;
  email: String;
  contact: String;
  employees?: Maybe<UserCreateManyWithoutAccountingFirmInput>;
}

export interface DataRecordScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  uploadTime?: Maybe<DateTimeInput>;
  uploadTime_not?: Maybe<DateTimeInput>;
  uploadTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  uploadTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  uploadTime_lt?: Maybe<DateTimeInput>;
  uploadTime_lte?: Maybe<DateTimeInput>;
  uploadTime_gt?: Maybe<DateTimeInput>;
  uploadTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DataRecordScalarWhereInput[] | DataRecordScalarWhereInput>;
  OR?: Maybe<DataRecordScalarWhereInput[] | DataRecordScalarWhereInput>;
  NOT?: Maybe<DataRecordScalarWhereInput[] | DataRecordScalarWhereInput>;
}

export interface StdSubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StdSubjectWhereInput>;
  AND?: Maybe<
    StdSubjectSubscriptionWhereInput[] | StdSubjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    StdSubjectSubscriptionWhereInput[] | StdSubjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StdSubjectSubscriptionWhereInput[] | StdSubjectSubscriptionWhereInput
  >;
}

export interface DataRecordUpdateManyWithWhereNestedInput {
  where: DataRecordScalarWhereInput;
  data: DataRecordUpdateManyDataInput;
}

export interface DataRecordSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DataRecordWhereInput>;
  AND?: Maybe<
    DataRecordSubscriptionWhereInput[] | DataRecordSubscriptionWhereInput
  >;
  OR?: Maybe<
    DataRecordSubscriptionWhereInput[] | DataRecordSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DataRecordSubscriptionWhereInput[] | DataRecordSubscriptionWhereInput
  >;
}

export interface DataRecordUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
}

export interface TbSubjectUpdateInput {
  show?: Maybe<String>;
  subject?: Maybe<String>;
  direction?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface StdSubjectUpdateInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
}

export interface MemberUpsertWithWhereUniqueWithoutProjectInput {
  where: MemberWhereUniqueInput;
  update: MemberUpdateWithoutProjectDataInput;
  create: MemberCreateWithoutProjectInput;
}

export interface ProjectUpdateWithoutMembersDataInput {
  accountingFirm?: Maybe<AccountingFirmUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
}

export interface MemberScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  role?: Maybe<ProjectRole>;
  role_not?: Maybe<ProjectRole>;
  role_in?: Maybe<ProjectRole[] | ProjectRole>;
  role_not_in?: Maybe<ProjectRole[] | ProjectRole>;
  AND?: Maybe<MemberScalarWhereInput[] | MemberScalarWhereInput>;
  OR?: Maybe<MemberScalarWhereInput[] | MemberScalarWhereInput>;
  NOT?: Maybe<MemberScalarWhereInput[] | MemberScalarWhereInput>;
}

export interface HolderUpdateManyMutationInput {
  name?: Maybe<String>;
  ratio?: Maybe<Float>;
}

export interface MemberUpdateManyWithWhereNestedInput {
  where: MemberScalarWhereInput;
  data: MemberUpdateManyDataInput;
}

export type SubjectContrastWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  origin?: Maybe<String>;
}>;

export interface MemberUpdateManyDataInput {
  role?: Maybe<ProjectRole>;
}

export interface FSSubjectUpdateManyMutationInput {
  name?: Maybe<String>;
  show?: Maybe<String>;
  subject?: Maybe<String>;
  direction?: Maybe<String>;
}

export interface ProjectUpsertWithWhereUniqueNestedInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateDataInput;
  create: ProjectCreateInput;
}

export interface UserUpdateWithWhereUniqueWithoutDataRecordsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutDataRecordsDataInput;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface AccountingFirmCreateOneInput {
  create?: Maybe<AccountingFirmCreateInput>;
  connect?: Maybe<AccountingFirmWhereUniqueInput>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface MemberWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project?: Maybe<ProjectWhereInput>;
  user?: Maybe<UserWhereInput>;
  role?: Maybe<ProjectRole>;
  role_not?: Maybe<ProjectRole>;
  role_in?: Maybe<ProjectRole[] | ProjectRole>;
  role_not_in?: Maybe<ProjectRole[] | ProjectRole>;
  AND?: Maybe<MemberWhereInput[] | MemberWhereInput>;
  OR?: Maybe<MemberWhereInput[] | MemberWhereInput>;
  NOT?: Maybe<MemberWhereInput[] | MemberWhereInput>;
}

export interface ProjectUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  password?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  name?: Maybe<String>;
  role?: Maybe<Role>;
}

export interface UserUpsertWithWhereUniqueWithoutAccountingFirmInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutAccountingFirmDataInput;
  create: UserCreateWithoutAccountingFirmInput;
}

export interface ProjectUpdateInput {
  accountingFirm?: Maybe<AccountingFirmUpdateOneRequiredInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  members?: Maybe<MemberUpdateManyWithoutProjectInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  emailvalidated_not?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  validateEmailToken_not?: Maybe<String>;
  validateEmailToken_in?: Maybe<String[] | String>;
  validateEmailToken_not_in?: Maybe<String[] | String>;
  validateEmailToken_lt?: Maybe<String>;
  validateEmailToken_lte?: Maybe<String>;
  validateEmailToken_gt?: Maybe<String>;
  validateEmailToken_gte?: Maybe<String>;
  validateEmailToken_contains?: Maybe<String>;
  validateEmailToken_not_contains?: Maybe<String>;
  validateEmailToken_starts_with?: Maybe<String>;
  validateEmailToken_not_starts_with?: Maybe<String>;
  validateEmailToken_ends_with?: Maybe<String>;
  validateEmailToken_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordToken_not?: Maybe<String>;
  resetPasswordToken_in?: Maybe<String[] | String>;
  resetPasswordToken_not_in?: Maybe<String[] | String>;
  resetPasswordToken_lt?: Maybe<String>;
  resetPasswordToken_lte?: Maybe<String>;
  resetPasswordToken_gt?: Maybe<String>;
  resetPasswordToken_gte?: Maybe<String>;
  resetPasswordToken_contains?: Maybe<String>;
  resetPasswordToken_not_contains?: Maybe<String>;
  resetPasswordToken_starts_with?: Maybe<String>;
  resetPasswordToken_not_starts_with?: Maybe<String>;
  resetPasswordToken_ends_with?: Maybe<String>;
  resetPasswordToken_not_ends_with?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  resetPasswordExpires_not?: Maybe<Float>;
  resetPasswordExpires_in?: Maybe<Float[] | Float>;
  resetPasswordExpires_not_in?: Maybe<Float[] | Float>;
  resetPasswordExpires_lt?: Maybe<Float>;
  resetPasswordExpires_lte?: Maybe<Float>;
  resetPasswordExpires_gt?: Maybe<Float>;
  resetPasswordExpires_gte?: Maybe<Float>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface CompanyUpdateWithoutHoldersDataInput {
  type?: Maybe<CompanyType>;
  nature?: Maybe<CompanyNature>;
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  accountingFirms?: Maybe<AccountingFirmUpdateManyWithoutCustomersInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface DataRecordUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  emailvalidated?: Maybe<Boolean>;
  validateEmailToken?: Maybe<String>;
  password?: Maybe<String>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<Float>;
  name?: Maybe<String>;
  role?: Maybe<Role>;
}

export interface HolderCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  name: String;
  ratio: Float;
}

export interface CompanyUpdateInput {
  type?: Maybe<CompanyType>;
  nature?: Maybe<CompanyNature>;
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  legalRepresentative?: Maybe<String>;
  establishDate?: Maybe<DateTimeInput>;
  registeredCapital?: Maybe<String>;
  paidinCapital?: Maybe<String>;
  businessScope?: Maybe<String>;
  holders?: Maybe<HolderUpdateManyWithoutCompanyInput>;
  accountingFirms?: Maybe<AccountingFirmUpdateManyWithoutCustomersInput>;
}

export interface DataRecordCreateInput {
  id?: Maybe<ID_Input>;
  accountingFirm: AccountingFirmCreateOneInput;
  company: CompanyCreateOneInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  files?: Maybe<FileCreateManyInput>;
  users?: Maybe<UserCreateManyWithoutDataRecordsInput>;
}

export interface UserCreateManyWithoutDataRecordsInput {
  create?: Maybe<
    UserCreateWithoutDataRecordsInput[] | UserCreateWithoutDataRecordsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface AccountingFirmUpdateManyMutationInput {
  name?: Maybe<String>;
  code?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  email?: Maybe<String>;
  contact?: Maybe<String>;
}

export interface MemberSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MemberWhereInput>;
  AND?: Maybe<MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput>;
  OR?: Maybe<MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput>;
  NOT?: Maybe<MemberSubscriptionWhereInput[] | MemberSubscriptionWhereInput>;
}

export interface UserCreateManyWithoutAccountingFirmInput {
  create?: Maybe<
    | UserCreateWithoutAccountingFirmInput[]
    | UserCreateWithoutAccountingFirmInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface HolderCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  ratio: Float;
  company: CompanyCreateOneWithoutHoldersInput;
}

export interface ProjectCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  accountingFirm: AccountingFirmCreateOneInput;
  company: CompanyCreateOneInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
}

export interface FSSubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  show?: Maybe<String>;
  show_not?: Maybe<String>;
  show_in?: Maybe<String[] | String>;
  show_not_in?: Maybe<String[] | String>;
  show_lt?: Maybe<String>;
  show_lte?: Maybe<String>;
  show_gt?: Maybe<String>;
  show_gte?: Maybe<String>;
  show_contains?: Maybe<String>;
  show_not_contains?: Maybe<String>;
  show_starts_with?: Maybe<String>;
  show_not_starts_with?: Maybe<String>;
  show_ends_with?: Maybe<String>;
  show_not_ends_with?: Maybe<String>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  direction?: Maybe<String>;
  direction_not?: Maybe<String>;
  direction_in?: Maybe<String[] | String>;
  direction_not_in?: Maybe<String[] | String>;
  direction_lt?: Maybe<String>;
  direction_lte?: Maybe<String>;
  direction_gt?: Maybe<String>;
  direction_gte?: Maybe<String>;
  direction_contains?: Maybe<String>;
  direction_not_contains?: Maybe<String>;
  direction_starts_with?: Maybe<String>;
  direction_not_starts_with?: Maybe<String>;
  direction_ends_with?: Maybe<String>;
  direction_not_ends_with?: Maybe<String>;
  AND?: Maybe<FSSubjectWhereInput[] | FSSubjectWhereInput>;
  OR?: Maybe<FSSubjectWhereInput[] | FSSubjectWhereInput>;
  NOT?: Maybe<FSSubjectWhereInput[] | FSSubjectWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  emailvalidated: Boolean;
  validateEmailToken: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  password: String;
  resetPasswordToken: String;
  resetPasswordExpires?: Float;
  name: String;
  role: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  emailvalidated: () => Promise<Boolean>;
  validateEmailToken: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<Float>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  emailvalidated: () => Promise<AsyncIterator<Boolean>>;
  validateEmailToken: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  resetPasswordToken: () => Promise<AsyncIterator<String>>;
  resetPasswordExpires: () => Promise<AsyncIterator<Float>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface DataRecordConnection {
  pageInfo: PageInfo;
  edges: DataRecordEdge[];
}

export interface DataRecordConnectionPromise
  extends Promise<DataRecordConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataRecordEdge>>() => T;
  aggregate: <T = AggregateDataRecordPromise>() => T;
}

export interface DataRecordConnectionSubscription
  extends Promise<AsyncIterator<DataRecordConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataRecordEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataRecordSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  emailvalidated: Boolean;
  validateEmailToken: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  password: String;
  resetPasswordToken: String;
  resetPasswordExpires?: Float;
  name: String;
  role: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  emailvalidated: () => Promise<Boolean>;
  validateEmailToken: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<Float>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  accountingFirm: <T = AccountingFirmPromise>() => T;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataRecords: <T = FragmentableArray<DataRecord>>(args?: {
    where?: DataRecordWhereInput;
    orderBy?: DataRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  emailvalidated: () => Promise<AsyncIterator<Boolean>>;
  validateEmailToken: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  resetPasswordToken: () => Promise<AsyncIterator<String>>;
  resetPasswordExpires: () => Promise<AsyncIterator<Float>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  accountingFirm: <T = AccountingFirmSubscription>() => T;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataRecords: <T = Promise<AsyncIterator<DataRecordSubscription>>>(args?: {
    where?: DataRecordWhereInput;
    orderBy?: DataRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  emailvalidated: () => Promise<Boolean>;
  validateEmailToken: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<Float>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  accountingFirm: <T = AccountingFirmPromise>() => T;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataRecords: <T = FragmentableArray<DataRecord>>(args?: {
    where?: DataRecordWhereInput;
    orderBy?: DataRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateDataRecord {
  count: Int;
}

export interface AggregateDataRecordPromise
  extends Promise<AggregateDataRecord>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataRecordSubscription
  extends Promise<AsyncIterator<AggregateDataRecord>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectContrastPreviousValues {
  id: ID_Output;
  origin: String;
  tb: String;
  fs: String;
  coefficient: Int;
  direction: String;
  firstClass: String;
  secondClass: String;
}

export interface SubjectContrastPreviousValuesPromise
  extends Promise<SubjectContrastPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  origin: () => Promise<String>;
  tb: () => Promise<String>;
  fs: () => Promise<String>;
  coefficient: () => Promise<Int>;
  direction: () => Promise<String>;
  firstClass: () => Promise<String>;
  secondClass: () => Promise<String>;
}

export interface SubjectContrastPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectContrastPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  origin: () => Promise<AsyncIterator<String>>;
  tb: () => Promise<AsyncIterator<String>>;
  fs: () => Promise<AsyncIterator<String>>;
  coefficient: () => Promise<AsyncIterator<Int>>;
  direction: () => Promise<AsyncIterator<String>>;
  firstClass: () => Promise<AsyncIterator<String>>;
  secondClass: () => Promise<AsyncIterator<String>>;
}

export interface DataRecordEdge {
  node: DataRecord;
  cursor: String;
}

export interface DataRecordEdgePromise
  extends Promise<DataRecordEdge>,
    Fragmentable {
  node: <T = DataRecordPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataRecordEdgeSubscription
  extends Promise<AsyncIterator<DataRecordEdge>>,
    Fragmentable {
  node: <T = DataRecordSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TbSubjectPreviousValues {
  id: ID_Output;
  show: String;
  subject: String;
  direction: String;
  order: Int;
}

export interface TbSubjectPreviousValuesPromise
  extends Promise<TbSubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  show: () => Promise<String>;
  subject: () => Promise<String>;
  direction: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface TbSubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<TbSubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  show: () => Promise<AsyncIterator<String>>;
  subject: () => Promise<AsyncIterator<String>>;
  direction: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTbSubject {
  count: Int;
}

export interface AggregateTbSubjectPromise
  extends Promise<AggregateTbSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTbSubjectSubscription
  extends Promise<AsyncIterator<AggregateTbSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TbSubjectConnection {
  pageInfo: PageInfo;
  edges: TbSubjectEdge[];
}

export interface TbSubjectConnectionPromise
  extends Promise<TbSubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TbSubjectEdge>>() => T;
  aggregate: <T = AggregateTbSubjectPromise>() => T;
}

export interface TbSubjectConnectionSubscription
  extends Promise<AsyncIterator<TbSubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TbSubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTbSubjectSubscription>() => T;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface TbSubject {
  id: ID_Output;
  show: String;
  subject: String;
  direction: String;
  order: Int;
}

export interface TbSubjectPromise extends Promise<TbSubject>, Fragmentable {
  id: () => Promise<ID_Output>;
  show: () => Promise<String>;
  subject: () => Promise<String>;
  direction: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface TbSubjectSubscription
  extends Promise<AsyncIterator<TbSubject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  show: () => Promise<AsyncIterator<String>>;
  subject: () => Promise<AsyncIterator<String>>;
  direction: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface TbSubjectNullablePromise
  extends Promise<TbSubject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  show: () => Promise<String>;
  subject: () => Promise<String>;
  direction: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface TbSubjectSubscriptionPayload {
  mutation: MutationType;
  node: TbSubject;
  updatedFields: String[];
  previousValues: TbSubjectPreviousValues;
}

export interface TbSubjectSubscriptionPayloadPromise
  extends Promise<TbSubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TbSubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TbSubjectPreviousValuesPromise>() => T;
}

export interface TbSubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TbSubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TbSubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TbSubjectPreviousValuesSubscription>() => T;
}

export interface SubjectContrastEdge {
  node: SubjectContrast;
  cursor: String;
}

export interface SubjectContrastEdgePromise
  extends Promise<SubjectContrastEdge>,
    Fragmentable {
  node: <T = SubjectContrastPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectContrastEdgeSubscription
  extends Promise<AsyncIterator<SubjectContrastEdge>>,
    Fragmentable {
  node: <T = SubjectContrastSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountingFirmSubscriptionPayload {
  mutation: MutationType;
  node: AccountingFirm;
  updatedFields: String[];
  previousValues: AccountingFirmPreviousValues;
}

export interface AccountingFirmSubscriptionPayloadPromise
  extends Promise<AccountingFirmSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountingFirmPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountingFirmPreviousValuesPromise>() => T;
}

export interface AccountingFirmSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountingFirmSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountingFirmSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountingFirmPreviousValuesSubscription>() => T;
}

export interface SubjectContrast {
  id: ID_Output;
  origin: String;
  tb: String;
  fs: String;
  coefficient: Int;
  direction: String;
  firstClass: String;
  secondClass: String;
}

export interface SubjectContrastPromise
  extends Promise<SubjectContrast>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  origin: () => Promise<String>;
  tb: () => Promise<String>;
  fs: () => Promise<String>;
  coefficient: () => Promise<Int>;
  direction: () => Promise<String>;
  firstClass: () => Promise<String>;
  secondClass: () => Promise<String>;
}

export interface SubjectContrastSubscription
  extends Promise<AsyncIterator<SubjectContrast>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  origin: () => Promise<AsyncIterator<String>>;
  tb: () => Promise<AsyncIterator<String>>;
  fs: () => Promise<AsyncIterator<String>>;
  coefficient: () => Promise<AsyncIterator<Int>>;
  direction: () => Promise<AsyncIterator<String>>;
  firstClass: () => Promise<AsyncIterator<String>>;
  secondClass: () => Promise<AsyncIterator<String>>;
}

export interface SubjectContrastNullablePromise
  extends Promise<SubjectContrast | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  origin: () => Promise<String>;
  tb: () => Promise<String>;
  fs: () => Promise<String>;
  coefficient: () => Promise<Int>;
  direction: () => Promise<String>;
  firstClass: () => Promise<String>;
  secondClass: () => Promise<String>;
}

export interface AccountingFirmPreviousValues {
  id: ID_Output;
  name: String;
  code: String;
  address: String;
  phone: String;
  email: String;
  contact: String;
}

export interface AccountingFirmPreviousValuesPromise
  extends Promise<AccountingFirmPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  address: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  contact: () => Promise<String>;
}

export interface AccountingFirmPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountingFirmPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<String>>;
}

export interface StdSubjectEdge {
  node: StdSubject;
  cursor: String;
}

export interface StdSubjectEdgePromise
  extends Promise<StdSubjectEdge>,
    Fragmentable {
  node: <T = StdSubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StdSubjectEdgeSubscription
  extends Promise<AsyncIterator<StdSubjectEdge>>,
    Fragmentable {
  node: <T = StdSubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccountingFirm {
  count: Int;
}

export interface AggregateAccountingFirmPromise
  extends Promise<AggregateAccountingFirm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountingFirmSubscription
  extends Promise<AsyncIterator<AggregateAccountingFirm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  type: CompanyType;
  nature: CompanyNature;
  name: String;
  code?: String;
  address?: String;
  legalRepresentative?: String;
  establishDate?: DateTimeOutput;
  registeredCapital?: String;
  paidinCapital?: String;
  businessScope?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<CompanyType>;
  nature: () => Promise<CompanyNature>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  address: () => Promise<String>;
  legalRepresentative: () => Promise<String>;
  establishDate: () => Promise<DateTimeOutput>;
  registeredCapital: () => Promise<String>;
  paidinCapital: () => Promise<String>;
  businessScope: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<CompanyType>>;
  nature: () => Promise<AsyncIterator<CompanyNature>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  legalRepresentative: () => Promise<AsyncIterator<String>>;
  establishDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  registeredCapital: () => Promise<AsyncIterator<String>>;
  paidinCapital: () => Promise<AsyncIterator<String>>;
  businessScope: () => Promise<AsyncIterator<String>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface AccountingFirmEdge {
  node: AccountingFirm;
  cursor: String;
}

export interface AccountingFirmEdgePromise
  extends Promise<AccountingFirmEdge>,
    Fragmentable {
  node: <T = AccountingFirmPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountingFirmEdgeSubscription
  extends Promise<AsyncIterator<AccountingFirmEdge>>,
    Fragmentable {
  node: <T = AccountingFirmSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MemberEdge {
  node: Member;
  cursor: String;
}

export interface MemberEdgePromise extends Promise<MemberEdge>, Fragmentable {
  node: <T = MemberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MemberEdgeSubscription
  extends Promise<AsyncIterator<MemberEdge>>,
    Fragmentable {
  node: <T = MemberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataRecordSubscriptionPayload {
  mutation: MutationType;
  node: DataRecord;
  updatedFields: String[];
  previousValues: DataRecordPreviousValues;
}

export interface DataRecordSubscriptionPayloadPromise
  extends Promise<DataRecordSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataRecordPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataRecordPreviousValuesPromise>() => T;
}

export interface DataRecordSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataRecordSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataRecordSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataRecordPreviousValuesSubscription>() => T;
}

export interface AggregateHolder {
  count: Int;
}

export interface AggregateHolderPromise
  extends Promise<AggregateHolder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHolderSubscription
  extends Promise<AsyncIterator<AggregateHolder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataRecordPreviousValues {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  uploadTime: DateTimeOutput;
}

export interface DataRecordPreviousValuesPromise
  extends Promise<DataRecordPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  uploadTime: () => Promise<DateTimeOutput>;
}

export interface DataRecordPreviousValuesSubscription
  extends Promise<AsyncIterator<DataRecordPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  uploadTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HolderConnection {
  pageInfo: PageInfo;
  edges: HolderEdge[];
}

export interface HolderConnectionPromise
  extends Promise<HolderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HolderEdge>>() => T;
  aggregate: <T = AggregateHolderPromise>() => T;
}

export interface HolderConnectionSubscription
  extends Promise<AsyncIterator<HolderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HolderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHolderSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FSSubjectSubscriptionPayload {
  mutation: MutationType;
  node: FSSubject;
  updatedFields: String[];
  previousValues: FSSubjectPreviousValues;
}

export interface FSSubjectSubscriptionPayloadPromise
  extends Promise<FSSubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FSSubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FSSubjectPreviousValuesPromise>() => T;
}

export interface FSSubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FSSubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FSSubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FSSubjectPreviousValuesSubscription>() => T;
}

export interface AggregateFSSubject {
  count: Int;
}

export interface AggregateFSSubjectPromise
  extends Promise<AggregateFSSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFSSubjectSubscription
  extends Promise<AsyncIterator<AggregateFSSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FSSubjectPreviousValues {
  id: ID_Output;
  name: String;
  show: String;
  subject: String;
  direction: String;
}

export interface FSSubjectPreviousValuesPromise
  extends Promise<FSSubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  show: () => Promise<String>;
  subject: () => Promise<String>;
  direction: () => Promise<String>;
}

export interface FSSubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<FSSubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  show: () => Promise<AsyncIterator<String>>;
  subject: () => Promise<AsyncIterator<String>>;
  direction: () => Promise<AsyncIterator<String>>;
}

export interface FSSubjectConnection {
  pageInfo: PageInfo;
  edges: FSSubjectEdge[];
}

export interface FSSubjectConnectionPromise
  extends Promise<FSSubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FSSubjectEdge>>() => T;
  aggregate: <T = AggregateFSSubjectPromise>() => T;
}

export interface FSSubjectConnectionSubscription
  extends Promise<AsyncIterator<FSSubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FSSubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFSSubjectSubscription>() => T;
}

export interface AccountingFirmConnection {
  pageInfo: PageInfo;
  edges: AccountingFirmEdge[];
}

export interface AccountingFirmConnectionPromise
  extends Promise<AccountingFirmConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountingFirmEdge>>() => T;
  aggregate: <T = AggregateAccountingFirmPromise>() => T;
}

export interface AccountingFirmConnectionSubscription
  extends Promise<AsyncIterator<AccountingFirmConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccountingFirmEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccountingFirmSubscription>() => T;
}

export interface FSSubject {
  id: ID_Output;
  name: String;
  show: String;
  subject: String;
  direction: String;
}

export interface FSSubjectPromise extends Promise<FSSubject>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  show: () => Promise<String>;
  subject: () => Promise<String>;
  direction: () => Promise<String>;
}

export interface FSSubjectSubscription
  extends Promise<AsyncIterator<FSSubject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  show: () => Promise<AsyncIterator<String>>;
  subject: () => Promise<AsyncIterator<String>>;
  direction: () => Promise<AsyncIterator<String>>;
}

export interface FSSubjectNullablePromise
  extends Promise<FSSubject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  show: () => Promise<String>;
  subject: () => Promise<String>;
  direction: () => Promise<String>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  path: String;
  filename: String;
  mimetype: String;
  type: FileType;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  type: () => Promise<FileType>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<FileType>>;
}

export interface AccountingFirm {
  id: ID_Output;
  name: String;
  code: String;
  address: String;
  phone: String;
  email: String;
  contact: String;
}

export interface AccountingFirmPromise
  extends Promise<AccountingFirm>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  address: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  contact: () => Promise<String>;
  employees: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customers: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AccountingFirmSubscription
  extends Promise<AsyncIterator<AccountingFirm>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<String>>;
  employees: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customers: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AccountingFirmNullablePromise
  extends Promise<AccountingFirm | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  address: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  contact: () => Promise<String>;
  employees: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  customers: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Company {
  id: ID_Output;
  type: CompanyType;
  nature: CompanyNature;
  name: String;
  code?: String;
  address?: String;
  legalRepresentative?: String;
  establishDate?: DateTimeOutput;
  registeredCapital?: String;
  paidinCapital?: String;
  businessScope?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<CompanyType>;
  nature: () => Promise<CompanyNature>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  address: () => Promise<String>;
  legalRepresentative: () => Promise<String>;
  establishDate: () => Promise<DateTimeOutput>;
  registeredCapital: () => Promise<String>;
  paidinCapital: () => Promise<String>;
  businessScope: () => Promise<String>;
  holders: <T = FragmentableArray<Holder>>(args?: {
    where?: HolderWhereInput;
    orderBy?: HolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accountingFirms: <T = FragmentableArray<AccountingFirm>>(args?: {
    where?: AccountingFirmWhereInput;
    orderBy?: AccountingFirmOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<CompanyType>>;
  nature: () => Promise<AsyncIterator<CompanyNature>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  legalRepresentative: () => Promise<AsyncIterator<String>>;
  establishDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  registeredCapital: () => Promise<AsyncIterator<String>>;
  paidinCapital: () => Promise<AsyncIterator<String>>;
  businessScope: () => Promise<AsyncIterator<String>>;
  holders: <T = Promise<AsyncIterator<HolderSubscription>>>(args?: {
    where?: HolderWhereInput;
    orderBy?: HolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accountingFirms: <
    T = Promise<AsyncIterator<AccountingFirmSubscription>>
  >(args?: {
    where?: AccountingFirmWhereInput;
    orderBy?: AccountingFirmOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<CompanyType>;
  nature: () => Promise<CompanyNature>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  address: () => Promise<String>;
  legalRepresentative: () => Promise<String>;
  establishDate: () => Promise<DateTimeOutput>;
  registeredCapital: () => Promise<String>;
  paidinCapital: () => Promise<String>;
  businessScope: () => Promise<String>;
  holders: <T = FragmentableArray<Holder>>(args?: {
    where?: HolderWhereInput;
    orderBy?: HolderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accountingFirms: <T = FragmentableArray<AccountingFirm>>(args?: {
    where?: AccountingFirmWhereInput;
    orderBy?: AccountingFirmOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SubjectContrastConnection {
  pageInfo: PageInfo;
  edges: SubjectContrastEdge[];
}

export interface SubjectContrastConnectionPromise
  extends Promise<SubjectContrastConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectContrastEdge>>() => T;
  aggregate: <T = AggregateSubjectContrastPromise>() => T;
}

export interface SubjectContrastConnectionSubscription
  extends Promise<AsyncIterator<SubjectContrastConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectContrastEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectContrastSubscription>() => T;
}

export interface HolderSubscriptionPayload {
  mutation: MutationType;
  node: Holder;
  updatedFields: String[];
  previousValues: HolderPreviousValues;
}

export interface HolderSubscriptionPayloadPromise
  extends Promise<HolderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HolderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HolderPreviousValuesPromise>() => T;
}

export interface HolderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HolderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HolderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HolderPreviousValuesSubscription>() => T;
}

export interface StdSubjectConnection {
  pageInfo: PageInfo;
  edges: StdSubjectEdge[];
}

export interface StdSubjectConnectionPromise
  extends Promise<StdSubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StdSubjectEdge>>() => T;
  aggregate: <T = AggregateStdSubjectPromise>() => T;
}

export interface StdSubjectConnectionSubscription
  extends Promise<AsyncIterator<StdSubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StdSubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStdSubjectSubscription>() => T;
}

export interface HolderPreviousValues {
  id: ID_Output;
  name: String;
  ratio: Float;
}

export interface HolderPreviousValuesPromise
  extends Promise<HolderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  ratio: () => Promise<Float>;
}

export interface HolderPreviousValuesSubscription
  extends Promise<AsyncIterator<HolderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  ratio: () => Promise<AsyncIterator<Float>>;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface File {
  id: ID_Output;
  path: String;
  filename: String;
  mimetype: String;
  type: FileType;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  type: () => Promise<FileType>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<FileType>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  type: () => Promise<FileType>;
}

export interface MemberConnection {
  pageInfo: PageInfo;
  edges: MemberEdge[];
}

export interface MemberConnectionPromise
  extends Promise<MemberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MemberEdge>>() => T;
  aggregate: <T = AggregateMemberPromise>() => T;
}

export interface MemberConnectionSubscription
  extends Promise<AsyncIterator<MemberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MemberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMemberSubscription>() => T;
}

export interface MemberSubscriptionPayload {
  mutation: MutationType;
  node: Member;
  updatedFields: String[];
  previousValues: MemberPreviousValues;
}

export interface MemberSubscriptionPayloadPromise
  extends Promise<MemberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MemberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MemberPreviousValuesPromise>() => T;
}

export interface MemberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MemberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MemberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MemberPreviousValuesSubscription>() => T;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MemberPreviousValues {
  id: ID_Output;
  role: ProjectRole;
}

export interface MemberPreviousValuesPromise
  extends Promise<MemberPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  role: () => Promise<ProjectRole>;
}

export interface MemberPreviousValuesSubscription
  extends Promise<AsyncIterator<MemberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  role: () => Promise<AsyncIterator<ProjectRole>>;
}

export interface FSSubjectEdge {
  node: FSSubject;
  cursor: String;
}

export interface FSSubjectEdgePromise
  extends Promise<FSSubjectEdge>,
    Fragmentable {
  node: <T = FSSubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FSSubjectEdgeSubscription
  extends Promise<AsyncIterator<FSSubjectEdge>>,
    Fragmentable {
  node: <T = FSSubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataRecord {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  uploadTime: DateTimeOutput;
}

export interface DataRecordPromise extends Promise<DataRecord>, Fragmentable {
  id: () => Promise<ID_Output>;
  accountingFirm: <T = AccountingFirmPromise>() => T;
  company: <T = CompanyPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  uploadTime: () => Promise<DateTimeOutput>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DataRecordSubscription
  extends Promise<AsyncIterator<DataRecord>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accountingFirm: <T = AccountingFirmSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  uploadTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  files: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DataRecordNullablePromise
  extends Promise<DataRecord | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accountingFirm: <T = AccountingFirmPromise>() => T;
  company: <T = CompanyPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  uploadTime: () => Promise<DateTimeOutput>;
  files: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface AggregateSubjectContrast {
  count: Int;
}

export interface AggregateSubjectContrastPromise
  extends Promise<AggregateSubjectContrast>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectContrastSubscription
  extends Promise<AsyncIterator<AggregateSubjectContrast>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StdSubject {
  id: ID_Output;
  code: String;
  name: String;
}

export interface StdSubjectPromise extends Promise<StdSubject>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface StdSubjectSubscription
  extends Promise<AsyncIterator<StdSubject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StdSubjectNullablePromise
  extends Promise<StdSubject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface Member {
  id: ID_Output;
  role: ProjectRole;
}

export interface MemberPromise extends Promise<Member>, Fragmentable {
  id: () => Promise<ID_Output>;
  project: <T = ProjectPromise>() => T;
  user: <T = UserPromise>() => T;
  role: () => Promise<ProjectRole>;
}

export interface MemberSubscription
  extends Promise<AsyncIterator<Member>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project: <T = ProjectSubscription>() => T;
  user: <T = UserSubscription>() => T;
  role: () => Promise<AsyncIterator<ProjectRole>>;
}

export interface MemberNullablePromise
  extends Promise<Member | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project: <T = ProjectPromise>() => T;
  user: <T = UserPromise>() => T;
  role: () => Promise<ProjectRole>;
}

export interface HolderEdge {
  node: Holder;
  cursor: String;
}

export interface HolderEdgePromise extends Promise<HolderEdge>, Fragmentable {
  node: <T = HolderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HolderEdgeSubscription
  extends Promise<AsyncIterator<HolderEdge>>,
    Fragmentable {
  node: <T = HolderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Project {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  accountingFirm: <T = AccountingFirmPromise>() => T;
  company: <T = CompanyPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  members: <T = FragmentableArray<Member>>(args?: {
    where?: MemberWhereInput;
    orderBy?: MemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accountingFirm: <T = AccountingFirmSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  members: <T = Promise<AsyncIterator<MemberSubscription>>>(args?: {
    where?: MemberWhereInput;
    orderBy?: MemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accountingFirm: <T = AccountingFirmPromise>() => T;
  company: <T = CompanyPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  members: <T = FragmentableArray<Member>>(args?: {
    where?: MemberWhereInput;
    orderBy?: MemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SubjectContrastSubscriptionPayload {
  mutation: MutationType;
  node: SubjectContrast;
  updatedFields: String[];
  previousValues: SubjectContrastPreviousValues;
}

export interface SubjectContrastSubscriptionPayloadPromise
  extends Promise<SubjectContrastSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectContrastPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectContrastPreviousValuesPromise>() => T;
}

export interface SubjectContrastSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectContrastSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectContrastSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectContrastPreviousValuesSubscription>() => T;
}

export interface Holder {
  id: ID_Output;
  name: String;
  ratio: Float;
}

export interface HolderPromise extends Promise<Holder>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  ratio: () => Promise<Float>;
  company: <T = CompanyPromise>() => T;
}

export interface HolderSubscription
  extends Promise<AsyncIterator<Holder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  ratio: () => Promise<AsyncIterator<Float>>;
  company: <T = CompanySubscription>() => T;
}

export interface HolderNullablePromise
  extends Promise<Holder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  ratio: () => Promise<Float>;
  company: <T = CompanyPromise>() => T;
}

export interface StdSubjectPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface StdSubjectPreviousValuesPromise
  extends Promise<StdSubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface StdSubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<StdSubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StdSubjectSubscriptionPayload {
  mutation: MutationType;
  node: StdSubject;
  updatedFields: String[];
  previousValues: StdSubjectPreviousValues;
}

export interface StdSubjectSubscriptionPayloadPromise
  extends Promise<StdSubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StdSubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StdSubjectPreviousValuesPromise>() => T;
}

export interface StdSubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StdSubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StdSubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StdSubjectPreviousValuesSubscription>() => T;
}

export interface TbSubjectEdge {
  node: TbSubject;
  cursor: String;
}

export interface TbSubjectEdgePromise
  extends Promise<TbSubjectEdge>,
    Fragmentable {
  node: <T = TbSubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TbSubjectEdgeSubscription
  extends Promise<AsyncIterator<TbSubjectEdge>>,
    Fragmentable {
  node: <T = TbSubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface AggregateMember {
  count: Int;
}

export interface AggregateMemberPromise
  extends Promise<AggregateMember>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMemberSubscription
  extends Promise<AsyncIterator<AggregateMember>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateStdSubject {
  count: Int;
}

export interface AggregateStdSubjectPromise
  extends Promise<AggregateStdSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStdSubjectSubscription
  extends Promise<AsyncIterator<AggregateStdSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "AccountingFirm",
    embedded: false
  },
  {
    name: "CompanyType",
    embedded: false
  },
  {
    name: "CompanyNature",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Holder",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "ProjectRole",
    embedded: false
  },
  {
    name: "Member",
    embedded: false
  },
  {
    name: "DataRecord",
    embedded: false
  },
  {
    name: "FileType",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "SubjectContrast",
    embedded: false
  },
  {
    name: "TbSubject",
    embedded: false
  },
  {
    name: "FSSubject",
    embedded: false
  },
  {
    name: "StdSubject",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
